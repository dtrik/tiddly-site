created: 20201021173801100
modified: 20201021174042800
revision: 2
tags: [[Steve Yegge's Guide]] summary
title: Steve Yegge Summary
type: text/vnd.tiddlywiki

* Study a data-structures and algorithms book: Recommends Steven Skiena's The Algorithm Design Manual.  Practice the art of recognizing that certain problem classes are best solved with certain algorithms and data structures. Understand just how astonishingly commonplace (and important) graph problems are â€“ they should be part of every working programmer's toolkit. If more time is available, go through Cormen.

* Have someone interview you

* Practice whiteboarding

* You should go in humble, open-minded, and focused. Treat every question as legitimate, even if you are frustrated that you don't know the answer.

* Ask if they care about syntax, and if they do, try to get it right.

* Feel free to ask for help or hints if you're stuck.

* Even if you think you know the answer to the problem, ask some questions and talk about the approach you'll take a little before diving in.

Most important topics:

* Algorithm Complexity: you need to know Big-O. It's a must. 

* Sorting: know how to sort. You should know the details of at least one n*log(n) sorting algorithm, preferably two (say, quicksort and merge sort).

* Hashtables: hashtables are arguably the single most important data structure known to mankind. You absolutely have to know how they work.

* Trees: you should know about trees. Know basic tree construction, traversal and manipulation algorithms. You should be familiar with binary trees, n-ary trees, and trie-trees at the very very least. You should be familiar with at least one flavor of balanced binary tree, whether it's a red/black tree, a splay tree or an AVL tree. You should actually know how it's implemented. You should know about tree traversal algorithms: BFS and DFS, and know the difference between inorder, postorder and preorder.

* Graphs: Graphs are really really important. There are three basic ways to represent a graph in memory (objects and pointers, matrix, and adjacency list), and you should familiarize yourself with each representation and its pros and cons. You should know the basic graph traversal algorithms: breadth-first search and depth-first search. You should know their computational complexity, their tradeoffs, and how to implement them in real code. You should try to study up on fancier algorithms, such as Dijkstra and A*. Whenever someone gives you a problem, think graphs. They are the most fundamental and flexible way of representing any kind of a relationship, so it's about a 50-50 shot that any interesting design problem has a graph involved in it. Make absolutely sure you can't think of a way to solve it using graphs before moving on to other solution types. 

* Other data structures: You should study up on as many other data structures and algorithms as you can fit. You should especially know about the most famous classes of NP-complete problems, such as traveling salesman and the knapsack problem, and be able to recognize them when an interviewer asks you them in disguise. Basically, hit that data structures book hard, and try to retain as much of it as you can, and you can't go wrong.

* Math: Teach yourself the essentials of combinatorics and probability

* Operating Systems: Know about processes, threads and concurrency issues. Know about locks and mutexes and semaphores and monitors and how they work. Know about deadlock and livelock and how to avoid them. Know what resources a processes needs, and a thread needs, and how context switching works, and how it's initiated by the operating system and underlying hardware. Know a little about scheduling.

You will be expected to know a fair amount of detail about your favorite programming language.